fr: Calendriers
en: Calendars
calfr: dir
calfr-dbg: dir
cvtcar: code
subsg: code
---
- section: 0
  fr: Conversion entre calendriers
  en: Conversion between calendars
- fr: |
    Cette série de programmes s'applique à trois calendriers
    différents.

    <ul>
    <li> Le calendrier grégorien proleptique. Il s'agit du
    calendrier grégorien, extrapolé dans le passé au-delà
    de l'année 1582, bien que la HP-48
    n'accepte les dates qu'à partir de cette année.
    Les dates grégoriennes sont exprimées avec un nombre au format
    JJ,MMAAAA ou bien MM,JJAAAA, en fonction de l'indicateur -42.</li>

    <li> Le <i lang='la'>Rata Die</i> (RD). C'est un calendrier qui 
    ignore totalement les années.  Il ne compte que les jours, à partir
    du 1<sup>er</sup> janvier de l'an 1 du calendrier grégorien
    proleptique. Très pratique pour les 
    calculateurs, beaucoup moins pour les humains.</li>

    <li> Le calendrier républicain. Le calendrier républicain
    a été en vigueur de 1792 à 1805, mais les programmes permettent
    d'utiliser des dates jusqu'à aujourd'hui et au-delà.
    Les dates sont exprimées par un nombre au format AAAAMMJJ.
    Il y a douze mois de 30 jours chacun, plus 5 ou 6&nbsp;jours
    complémentaires à la fin de l'année. Pour des raisons de simplicité,
    ces jours complémentaires constituent un mois supplémentaire numéroté 13.
    </li>
    </ul>
- en: |
    This group of programs applies to three different calendars.

    <ul>
    <li> The proleptic Gregorian calendar. This is the Gregorian
    calendar, but extending in the past farther than 1582, although
    the HP-48 accepts dates only after this year. The Gregorian dates
    are written in the standard HP-48 way, that is, DD,MMYYYY or
    MM,DDYYYY depending on the setting of flag -42.
    </li>
    <li>The <i lang='la'>Rata Die</i> calendar. This calendar ignores
    completely the notion of year. It counts only the days since 
    January 1st, year 1, in the proleptic Gregorian calendar.
    Very convenient for computers, much less for humans.
    </li>
    <li>The French Revolutionary calendar. This calendar was in effect
    in France only and from 1792 to 1805 only, but the programs allow you to
    use dates past this limit, until today and beyond. The dates are
    entered as integer numbers YYYYMMDD. This calendar contains
    12 months of 30 days each, plus 5 or 6 additional days. For convenience,
    these additional days are grouped together in what is considered
    as an additional month, numbered 13.
    </li>
    </ul>

- section: 0
  fr: Mode d'emploi
  en: Instructions for Use

- fr: |
    En fait, le calendrier <i lang='la'>Rata Die</i> ne vous servira
    pas en tant que tel, mais simplement comme intermédiaire entre
    les deux autres.

    Pour déterminer à quelle date du calendrier républicain correspond
    le 6 juin 1944, voici comment procéder. Tapez au choix&nbsp;:
- en: |
    Actually, you will just use the <i lang='la'>Rata Die</i> calendar 
    as a step between the two other calendars.

    For example, you want to know which French Revolutionary date
    corresponds to June 6th, 1944. Just type any of:
- code: |
    6,061944 @GRFR@
    6,061944 @GRFR@ @FRABR@
    6,061944 @GRFR@ @FRLONG@
- fr: |
    et vous apprenez qu'il s'agit d'octidi, 18 prairial CLII.
    Selon le cas, vous obtenez le résultat sous forme
    numérique 1520918, sous forme abrégée «&nbsp;18&nbsp;PRA&nbsp;152&nbsp;»
    ou sous forme longue,
    «&nbsp;Octidi&nbsp;18&nbsp;Prairial&nbsp;CLII&nbsp;».
- en: |
    and you learn that it was octidi, 18 prairial CLII.
    Depending on the command you used, you obtain the 
    result as a number, 1520918, as an abbreviated string
    «&nbsp;18&nbsp;PRA&nbsp;152&nbsp;» or a long string
    «&nbsp;Octidi&nbsp;18&nbsp;Prairial&nbsp;CLII&nbsp;».
- fr: |
    La conversion dans l'autre sens nécessite que vous connaissiez
    l'ordre des mois et que vous fassiez de tête la conversion en
    nombre. Ainsi, pour convertir le décadi 20 brumaire CXXVII,
    vous convertissez de tête «&nbsp;brumaire&nbsp;» en «&nbsp;2&nbsp;»
    puis vous tapez&nbsp;:
- en: |
    The reverse conversion requires you to know the order of the
    months and to convert the date into a YYYYMMDD number by yourself.
    For example, if you want to convert décadi 20 brumaire CXXVII,
    you first have to convert «&nbsp;brumaire&nbsp;» into «&nbsp;2&nbsp;»
    and then, you write:
- code: |
    1270220 @FRGR@
- fr: |
    et vous obtenez 11,111918, c'est-à-dire le 11&nbsp;novembre 1918.
- en: |
    and the result is 11,111918, which is November 11th, 1918.
- fr: |
    Il avait été question de décimaliser l'heure, avec 
    10&nbsp;heures par jour, 100&nbsp;minutes par heure et 100&nbsp;secondes
    par minute. Cette partie de la réforme n'a jamais été 
    mise en application. Néanmoins, quelques programmes
    vous permettent d'utiliser une heure décimale.
- en: |
    Another reform had been proposed, but never put in effect, 
    the decimalisation of time. Each day was divided into 10 hours,
    each hour into 100 minutes and each minute into 100 seconds.
    Although this reform was never applied, a few programs
    allow you to use a decimal time.
- fr: |
    Les heures décimales sont exprimées comme les heures normales
    en H,MMSS. Pour convertir 19 h 45 en décimal, tapez au choix&nbsp;:
- en: |
    Decimal time has the same format as the usual sexagesimal time:
    H,MMSS. To convert 19 h 45 (or 7 h 45 PM) into decimal, type any of:
- code: |
    19,45 @H24H10@ @PRH10@
    19,45 @H24H10@
- fr: et vous obtenez le nombre 8,2292 ou la chaîne "8:22:92".
- en: and the result is either the number 8,2292 or the string "8:22:92".
- fr: |
    Une dernière commande utile est @MAINTENANT@, qui donne à la fois le
    jour et l'heure courants, en utilisant le format long.
- en: |
    A last command is @MAINTENANT@ (now), which gives the current day
    and current time in long format.
- section: 0
  'fr,en': Installation
- section: 0
  fr: Installation avec une carte SD
  en: Installation with a SD card
  level: 3
- fr: |
    Tout d'abord, il faut positionner le drapeau -51, pour que le délimiteur
    de la partie décimale soit la virgule et non pas le point.

    Sur le PC, copiez les fichiers <tt>subsg</tt>, <tt>cvtcar</tt>,
    l'un des fichiers <tt>calfr</tt> ou <tt>calfr-dbg</tt> sur la
    carte SD. Éventuellement, il faut copier le fichier <tt>frf</tt>,
    mais ce n'est pas obligatoire.
- en: |
    First, the -51 flag must be set, so the character separating the
    fractional part from the integer part will be the comma.

    On the PC, copy the following files: <tt>subsg</tt>, <tt>cvtcar</tt>,
    either <tt>calfr</tt> or <tt>calfr-dbg</tt> to the SD card.
    The <tt>frf</tt> file may be copied also, but this is not required.
- fr: |
    Débranchez la carte SD du PC et branchez-la sur la HP-50.
    Copiez les fichiers vers la HP-50.
- en: |
    Unplug the SD card from the PC and plug it into the HP-50.
    Copy the files to the HP-50.
- fr: |
    Passez en mode édition sur @SUBSG@. Sur la deuxième ligne, remplacez
    la chaîne <tt>"\\->"</tt> par une flèche <tt>\-></tt>
    (shift-droit zéro). Sauvegardez. Puis convertissez
    la chaîne en programme (PRG TYPE OBJ\-> ou bien shift-gauche N E A).
    Stockez le résultat dans @SUBSG@.
    Convertissez de même @CVTCAR@ par PRG TYPE OBJ\-> ou bien shift-gauche N E A.
    Puis stockez le récultat dans @CVTCAR@.
    Il n'y a pas besoin de remplacer une chaîne par une flèche.
- en: |
    Edit the content of @SUBSG@. On the second line, replace the
    <tt>"\\->"</tt> string by an arrow <tt>\-></tt> (right-shift zero).
    Save. Then convert it to a program (PRG TYPE OBJ\-> or left-shift N E A).
    Store the result into @SUBSG@.
    Convert also @CVTCAR@ with PRG TYPE OBJ\-> or left-shift N E A.
    Store the result into @CVTCAR@. No need to replace a substring with an arrow.
- fr: |
    Pour CALFR ou CALFR-DBG, il y a de nombreuses sous-chaînes à remplacer
    par des flèches ou d'autres caractères spéciaux. Pour ce faire, 
    chargez la chaîne au niveau 1 de la pile et lancez @CVTCAR@.
    Convertissez la chaîne en objet (PRG TYPE OBJ\-> ou bien shift-gauche N E A).
    Puis stockez le résultat dans un nom de répertoire à votre guise.
- en: |
    For CALFR or CALFR-DBG, there are many substrings to replace with special 
    characters. To do this, just load the string in the stack, level 1,
    and execture @CVTCAR@. Then, convert the string into an object
    (PRG TYPE OBJ\-> or left-shift N E A). Last, store the result in a
    directory name you choose.
- fr: |
    Si vous avez chargé le fichier <tt>frf</tt>, faites de même avec la chaîne
    FRF&nbsp;: chargez-la dans la pile, appliquez-lui @CVTCAR@, convertissez
    en objet et stockez le résultat dans la variable FRF. Déplacez cette
    variable vers le répertoire créé précédemment.
- en: |
    If you have copied the <tt>frf</tt> file, do the same procedure with 
    the FRF string: load into the stack, level 1, run @CVTCAR@, convert
    into an object and store the result into the FRF variable. Move this
    variable into the directory just created.
- section: 0
  fr: Les programmes
  en: The programs
- section: GRRD
  fr: Conversion de grégorien en  <i lang='la'>Rata Die</i>
  en: Conversion from Gregorian to <i lang='la'>Rata Die</i>
  calfr-dbg: 10
  level: 3
- fr: |
    La conversion grégorien \-> RD s'effectue
    en deux ou trois étapes. Prenons par exemple une date au
    13 septembre 1515 grégorien (une dizaine de jours avant la bataille de Marignan,
    qui a eu lieu les 13 et 14 septembre 1515 exprimés dans le calendrier
    julien).
    On se ramène à une date postérieure à 1600, par pas de 400 ans.
    Dans ce cas, cela donne 13 septembre 1915. Les trois étapes
    sont donc

    <ul>
    <li>le RD du 1<sup>er</sup> janvier 2001 (une constante, 730486),</li>
    <li>le nombre de jours (algébrique) du 1<sup>er</sup> janvier 2001 au 13 
    septembre 1915,</li>
    <li>le nombre de jours (algébrique) du 13 septembre 1915 au 13 
    septembre 1515 (étape inexistante si la date à convertir avait
    été postérieure au 31 décembre 1599).</li>
    </ul>

    À noter que l'un des avantages du 1<sup>er</sup> janvier 2001 est
    qu'il s'écrit de façon indépendante du flag -42. C'est
    1,012001 aussi bien en JJ,MMAAAA qu'en MM,JJAAAA.
- en: |
    The Gregorian \-> RD conversion is processed in two or three steps.
    Let us take, for example, the 13th September 1515 in the Gregorian
    Calendar (ten days before the Battle of Marignan, which took place
    on 13th September 1515, Julian calendar).
    The first step consists in reaching a date on 1600 or later, with
    400-year increments. In this case, this results in 13th September 1915.
    The three steps are:
    <ul>
    <li>The RD value for 1st January 2001 (constant 730486 or |JAN_2001|),</li>
    <li>The algebraical number of days from 1st January 2001 to 13th September
    1915,</li>
    <li>The algebraical number of days from 13th September 1915 to 13th September
    1515 (this step does not occur if the date to convert is later than 31th December 1599).</li>
    </ul>

- calfr-dbg: 1
  code: |
    «
- code: |
    .
      0 \-> GR RD
      «
        WHILE GR 100 * FP 10000 * 1600 <
        REPEAT
         ,0004  'GR' STO+
         146097 'RD' STO+
        END 
        1,012001 GR DDAYS RD - |JAN_2001| +
      »
- calfr-dbg: 1
  code: |
    »

- section: RDGR
  fr: Conversion de <i lang='la'>Rata Die</i> en grégorien.
  en: Conversion from <i lang='la'>Rata Die</i> into Gregorian.
  calfr-dbg: 11
  level: 3

- fr: |
    C'est le même principe en trois étapes, sauf que l'on se ramène
    à une date en 2001 ou postérieure, on ne se contente pas de 1600.
    Cela pourrait être modifié. Il suffit de calculer le RD de
    la date seuil.

- en: |
    This is the same method in three steps, except that the intermediary
    date is in 2001 or later, instead of just 1600. It could be modified,
    just change the threshold date.
    
- calfr-dbg: 1
  code: |
    «
- code: |
    .
      \-> J
      « 0
        WHILE J |JAN_2001| \<=
        REPEAT 
         ,0004 +
         146097 'J' STO+
        END 
        J |JAN_2001| - 
        1,012001 SWAP DATE+
        SWAP -
      »
- calfr-dbg: 1
  code: |
    »

- section: JAN_2001
  level: 4

- fr: |
    C'est la valeur <i lang='la'>Rata Die</i> du 1<sup>er</sup> janvier
    2001. Elle est facile à calculer. Le <i lang='la'>Rata Die</i> 
    du 1<sup>er</sup> janvier 1 est 1. À cela, il faut ajouter 2000 ans,
    soit 2000&nbsp;x&nbsp;365 = 730000, plus les 29 février. Il y a 500 années
    divisibles par 4, dont 15 ne sont pas bissextiles. Le nombre de 29 février
    est donc 485, d'où un total de 730486.

- en: |
    This is the <i lang='la'>Rata Die</i> value for January 1st, 2001.
    This value is simple to compute. The <i lang='la'>Rata Die</i>
    value of January 1st, 1 is obviously 1. We add 2000 years, that is,
    2000&nbsp;x&nbsp;365 = 730000, plus the number of February 29st in
    this period. There are 500 years multiple of 4, 15 of which are not
    leap years. Therefore, there are 485 leap years. And the sum
    of these numbers gives the result, 730486.

- code: |
    730486

- section: FRBIS
  level: 3
  fr: Nombre de jours bissextiles précédant l'année N  du calendrier républicain.
  en: Number of leap days preceding the French Revolutionary year N
  calfr-dbg: 14

- fr: |
    Jusqu'en l'an 20, les années bissextiles sont calculées pour que le 
    jour de l'an coïncide avec l'équinoxe d'automne. Les années 
    bissextiles sont donc les années 3, 7, 11 et 15. À partir de l'an 20, 
    on adopte la règle de Romme, purement arithmétique. C'est la même 
    règle modulo 4, 100 et 400 que pour le calendrier grégorien.

- en: |
    Until the year 20, the leap years were computed so that the first day of
    the year would be on the autumn equinox. The leap years were 3, 7, 11 and 15.
    Then, starting with year 20, the rule would be Romme's rule, a purely numerical one, 
    like the Gregorian rule, with a 4-modulus, a 100-modulus and a 400-modulus.

- fr: |
    En réalité, la fonction utilise le calcul de Romme avec les modulos pour
    toute la période, puis corrige le résultat pour les quelques cas où
    la règle de l'équinoxe donne un résultat différent.

- en: |
    In fact, the function uses the modulus rule all the time, and fixes the
    result for the few cases where the equinoxial rule differs from the modulus rule.
- code: |
    « \-> A
      « 'A' DECR 4 / IP 
        A 100 / IP - 
        A 400 / IP +
        IF { 3 7 11 15 } A POS 0 \=/
        THEN 1 +
        END
      »
    »

- section: FRRD
  fr: Conversion de républicain en <i lang='la'>Rata Die</i>
  en: Conversion from French Revolutionary to <i lang='la'>Rata Die</i>
  calfr: 12
  calfr-dbg: 12
  level: 3

- calfr-dbg: 1
  code: |
    « \-> F
- calfr: 1
  code: |
    « |FRBIS| \-> F FRBIS
- code: |
    .
      « F 100 MOD
        F 100 / IP 100 MOD 30 * +
        F 10000 / IP 'F' STO
        F 365 * + F @FRBIS@ + 654019 +
      »
    »

- section: RDFR
  fr: Conversion de <i lang='la'>Rata Die</i> en républicain
  en: Conversion from <i lang='la'>Rata Die</i> to French Revolutionary
  calfr-dbg: 13
  level: 3

- fr: |
    On commence par se ramener au ``zéro" Vendémiaire de
    l'an I. Puis on calcule une estimation de l'année,
    en se basant sur une durée de 365&nbsp;jours, ce
    qui donne donc une valeur plus élevée que la valeur
    réelle. Ensuite, on compare le 1<sup>er</sup> Vendémiaire
    de l'année calculée avec la date à traduire. Si la
    valeur calculée de l'année est trop forte, c'est-à-dire
    si le 1<sup>er</sup> Vendémiaire calculé est postérieur à la
    date à traduire, on recule d'un an. Ce test et ce
    recul sont dans une boucle, dans l'éventualité où
    l'estimation de l'année dépasserait la valeur véritable
    de 2, 3, voire plus (cela se produit au bout de 1&nbsp;500&nbsp;ans
    et des poussières, lorsque 365&nbsp;jours bissextiles se sont accumulés
    et que l'on demande la conversion d'une date de la fin de l'année). 
    Une fois le bon 1<sup>er</sup> Vendémiaire
    obtenu, on calcule le nombre de jours entre lui et
    la date à convertir, ce qui donne le nombre de mois
    et le nombre de jours dans le dernier mois.

- en: |
    We start by shifting the RD number to the "zeroth" Vendémiaire
    of year I. Then, we compute an estimate of the year, by using
    a 365-day duration, with no leap days. This gives an estimate 
    greater than the actual value. So, we compare the 1st Vendémiaire
    of this year with the date to translate. If the 1st Vendémiaire
    is later than the translated date, we go back one year and we
    iterate. This is done in a loop, because after 1500 years or so,
    the estimated year can be 2 or 3 more than the actual year, after
    365 leap days have accumulated. When we have reached the proper
    1st Vendémiaire, we compute the number of days between it
    and the translated date, which gives the number of months and
    the day number in the month.

- calfr-dbg: 1
  code: |
    «
- code: |
    .
      0 \-> J D
      «
        J 10100 @FRRD@ -
        365 / IP 10000 *
        10101 + 'D' STO
        WHILE D @FRRD@ J >
        REPEAT 
          D 10000 - 'D' STO
        END 
        J D @FRRD@ -
        DUP 30 / IP 100 *
        SWAP 30 MOD + D +
      »
- calfr-dbg: 1
  code: |
    »

- section: GRFR
  fr: Conversion de grégorien en républicain
  en: Conversion from Gregorian to French Revolutionary
  calfr: 2
  calfr-dbg: 2
  level: 3
- fr: |
    Les deux conversions GR \-> RD \-> FR enchaînées
- en: |
    The two conversions GR \-> RD \-> FR at once.
- calfr: 1
  code: |
    « |GRRD| |RDFR| »
- calfr-dbg: 1
  code: |
    « @GRRD@ @RDFR@ »
- section: FRGR
  fr: Conversion de républicain en grégorien
  en: Conversion from French Revolutionary to Gregorian
  calfr: 3
  calfr-dbg: 3
  level: 3
- fr: |
    Les deux conversions FR \-> RD \-> GR enchaînées
- en: |
    The two conversions FR \-> RD \-> GR at once.
- calfr: 1
  code: |
    « @FRRD@ |RDGR| »
- calfr-dbg: 1
  code: |
    « @FRRD@ @RDGR@ »
- section: 0
  fr: Affichage d'une date du calendrier républicain
  en: Printing a French Revolutionary calendar date

- fr: |
    Compte tenu de la taille, la variable FRF est facultative
    et l'affichage de la date tient compte du fait que
    FRF peut exister ou ne pas exister.

    Chaque élément de la liste FRF est composé d'un chiffre
    puis d'un texte. Le chiffre permet de savoir si le texte 
    commence par une voyelle ou une consonne et dans le
    second cas s'il est masculin ou féminin. Avec le cas
    spécial du pluriel pour le "jour des récompenses".
    Ce chiffre est traduit en un préfixe "jour du", 
    "jour de la" etc. Avec une nuance en plus&nbsp;:
    un "0" signifie "masculin en toute certitude"
    tandis qu'un "4" signifie "vraisemblablement masculin",
    tout comme "5" signifie "vraisemblablement féminin".
    C'est pour cela que l'on duplique la liste des
    préfixes sur elle-même.
- en: |
    Because of its size, the FRF variable is optional and
    the function printing the date can work no matter whether the
    variable exists or not.

    Each element of the FRF list consists of a digit 
    and a string. The digit indicates if the string
    begins with a vowel or a consonant and, in the latter
    case, whether the name is masculine or feminine.
    And there is the special case of the 
    <i lang='fr'>jour des récompenses</i> (day of rewards)
    the only case where the noun is plural. And there is another subtlety:
    "0" means "definitely masculine", while "4" means "I think
    it is masculine, but I am not sure". Likewise, "1" is "definitely
    feminine", while "6" is "likely feminine". This is why the
    prefix list is duplicated and appended to itself.

- code: |
    {
    "0raisin" "0safran" "1châtaigne" "1colchique"
    ...
    "1vertu" "0génie" "0travail" "2opinion" 
    "3récompenses" "1révolution"
    }

- section: FRLONG
  fr: Date en format long
  en: Long format date
  calfr: 4
  calfr-dbg: 4
  level: 3
- calfr-dbg: 1
  code: |
    « \-> D
- calfr: 1
  code: |
    « |N10R| \-> D N10R
- code: |
    .
      « { "Primi" "Duo" "Tri" "Quarti" "Quinti"
            "Sexti" "Septi" "Octi" "Noni" "Déca" }
        D 1 - 10 MOD 1 + GET "di " +
        D 100 MOD + " " +
        { "Vendémiaire" "Brumaire" "Frimaire"
          "Nivôse" "Pluviôse" "Ventôse"
          "Germinal" "Floréal" "Prairial"
          "Messidor" "Thermidor" "Fructidor"
          "jour additionnel" } 
        D 100 / IP 100 MOD GET + " " +
        D 10000 / IP @N10R@ +
        IF 'FRF' VTYPE 0 \>=
        THEN
          FRF D 100 MOD D 100 / IP 100 MOD 1 - 30 * + GET
          DUP 1 1 SUB
          { " jour du " " jour de la " " jour de l'"
            " jour des " }
          DUP + SWAP NUM 47 - GET SWAP 2 30 SUB + +
        END
      »
    »

- section: FRABR
  fr: Date en format abrégé
  en: Abbreviated format date
  calfr: 5
  calfr-dbg: 5
  level: 3

- code: |
    « \-> D
      « D 100 MOD " " +
        { "VND" "BRU" "FRI" "NIV" "PLU" "VNT"
        "GER" "FLO" "PRA" "MES" "THE" "FRU" "S-C" }
        D 100 / IP 100 MOD GET +
        " " + D 10000 / IP +
      »
    »

- section: MAINTENANT
  fr: Date du jour
  en: Current Date
  calfr: 1
  calfr-dbg: 1
  level: 3

- fr: |
    Routine qui affiche la date du jour et l'heure décimale.
- en: |
    This code (translation for "NOW") prints the current
    day and time.

- code: |
    « DATE @GRFR@ @FRLONG@
    " " + TIME @H24H10@ @PRH10@ + 21 @JUSTIF@ »

- section: 0
  fr: Heure décimale
  en: Decimal Time

- section: H24H10
  'fr,en': Conversion H24 \-> H10
  level: 3
  calfr: 6
  calfr-dbg: 6

- fr: |
    La décimalisation des minutes et secondes en fractions
    d'heures est une fonction standard du RPL. La décimalisation
    des heures-minutes-secondes s'en déduit ensuite avec
    une simple division.
- en: |
    Decimalisation of minutes and seconds as fractions of hours
    is a standard RPL function. The full decimalisation of hours,
    minutes and seconds is therefore this function followed 
    by a simple division.
- code: |
    « HMS\-> 2,4 /  »

- section: H10H24
  'fr,en': Conversion H10 \-> H24
  level: 3
  calfr: 7
  calfr-dbg: 7
- fr: |
    La fonction inverse de @H24H10@ ci-dessus.
- en: |
    The inverse function as @H24H10@ above.

- code: |
    « 2,4 * \->HMS »

- section: PRH10
  fr: Affichage de l'heure décimale
  en: Printing Decimal Time
  calfr: 8
  calfr-dbg: 8
  level: 3

- fr: |
    Affichage de l'heure décimale, sachant que le nombre
    8,0317 doit donner "8:03:17", pas "8:3:17"
    Cela peut servir également pour les heures habituelles,
    si vous acceptez d'avoir des heures à un seul chiffre
    jusqu'à "9:59:59", au lieu de "09:59:59".
- en: |
    This code prints the decimal time, with the provision
    that 8,0317 must give "8:03:17", not "8:3:17".
    It works also for ordinary hours, provided you do not
    mind having single-digit hours until "9:59:59", instead
    of "09:59:59".
- code: |
    «  DUP IP ":" +
      SWAP FP 100 * DUP IP
      IF DUP 9 \<=
      THEN "0" SWAP +
      END
      ":" + 
      SWAP FP 100 * IP
      IF DUP 9 \<=
      THEN "0" SWAP +
      END
      + +
    »

- section: 0
  fr: Outils annexes
  en: Various Utilities

- section: N10R
  fr: Nombres romains
  en: Roman Numbers
  level: 3
  calfr-dbg: 15

- fr: |
    L'affichage traditionnel des années du calendrier
    républicain utilise les chiffres romains. Voici la
    routine de conversion.

- en: |
    Traditionally, the years of the French calendar
    are written with Roman numerals. Here is the conversion function.

- calfr: 1
  code: |
    « 
      |NR| \-> \<-N NR
- calfr-dbg: 1
  code: |
    « \-> \<-N
- code: |
    .
      « ""
      1 3 START "M" 1000 @NR@ NEXT
      "CM" 900 @NR@
      "D"  500 @NR@
      "CD" 400 @NR@
      1 3 START "C"  100 @NR@ NEXT
      "XC"  90 @NR@
      "L"   50 @NR@
      "XL"  40 @NR@
      1 3 START "X"   10 @NR@ NEXT
      "IX"   9 @NR@
      "V"    5 @NR@
      "IV"   4 @NR@
      1 3 START "I"    1 @NR@ NEXT
      »
    »

- section: NR
  level: 4
  calfr-dbg: 16

- fr: |
    Le sous-programme <tt>NR</tt> a pour but
    de transvaser une valeur du nombre indo-arabe 
    <tt>\<-N</tt> vers le nombre romain
    (niveau&nbsp;3 de la pile), après s'être assuré toutefois 
    que c'était justifié. Au niveau 2, on a la valeur
    à transvaser en romain, au niveau 1 la même valeur 
    en indo-arabe.
- en: |
    The subprogram <tt>NR</tt> removes a number
    from the indo-arabic value (<tt>\<-N</tt> variable)
    and adds it to the Roman value (in the stack, at level 3), 
    but checks first that is is allowed. In level 2, we have
    the transferred value in Roman number and in level 1 we have
    the same value in indo-arabic.

- code: |
     « DUP
      IF \<-N \<=
      THEN '\<-N' SWAP STO- +
      ELSE DROP2
      END
     »

- section: JUSTIF
  fr: Justification de chaîne
  en: String Justification
  calfr: 9
  calfr-dbg: 9

- fr: |
    Cette routine n'a rien à voir intrinsèquement avec
    le calendrier républicain. Elle permet d'assurer l'affichage
    d'une chaîne pour une largeur d'écran donnée, en remplaçant
    des espaces bien choisis par des sauts de ligne. Au niveau&nbsp;2,
    mettre la chaîne, au niveau&nbsp;1, renseigner la largeur de
    l'affichage.

- en: |
    This routine is not closely linked with the French calendar.
    It allows the proper display of a string in a screen with 
    a given width. For this, it replaces spaces with newlines.
    The string is in level 2 and the width is in level 1.

- fr: |
    <tt>I</tt> est l'indice du caractère courant, <tt>I10</tt>
    l'indice du dernier saut de ligne rencontré et <tt>I32</tt>
    l'indice du dernier espace rencontré. La condition pour
    remplacer un blanc par un saut de ligne s'interprête
    de la façon suivante&nbsp;:

- en: |
    <tt>I</tt> is the index of the current character, <tt>I10</tt>
    is the index of the last encountered linefeed and <tt>I32</tt>
    is the index of the last encountered space. The condition
    to replace a space by a linefeed consists of the following:

- fr: |
    1<sup>er</sup> cas, il y a au moins un espace parmi les <tt>LG</tt>
    premiers caractères de la ligne. En d'autres termes, 
    l'expression <tt>I32&nbsp;I10&nbsp;&gt;</tt> est vraie. La substitution
    s'effectue dès que <tt>I</tt> dépasse <tt>I10&nbsp;LG&nbsp;+</tt>,
    c'est-à-dire dès que <tt>I&nbsp;I10&nbsp;-&nbsp;LG&nbsp;&gt;</tt> devient vraie.

    2<sup>me</sup> cas, il y a plus de <tt>LG</tt> caractères d'affilée.
    Ce qui signifie que <tt>I&nbsp;I10&nbsp;-&nbsp;LG&nbsp;&gt;</tt> est vraie depuis
    un certain temps. On effectue alors le remplacement
    dès que l'on trouve un espace, c'est-à-dire lorsque
    <tt>I&nbsp;I32&nbsp;==</tt> est vraie.

- en: |
    First case, there is at least one space among the first <tt>LG</tt>
    characters of the current line. In other words, the expression
    <tt>I32&nbsp;I10&nbsp;&gt;</tt> is true. The substitution is executed
    as soon as <tt>I</tt> overcomes <tt>I10&nbsp;LG&nbsp;+</tt>, that is,
    as soon as <tt>I&nbsp;I10&nbsp;-&nbsp;LG&nbsp;&gt;</tt> turns true.
 
    Second case, there are more than <tt>LG</tt> successive characters.
    That means that <tt>I&nbsp;I10&nbsp;-&nbsp;LG&nbsp;&gt;</tt> has been true
    for some time. So we execute the substitution on the first space, that is,
    when <tt>I&nbsp;I32&nbsp;==</tt> turns true.
- fr: |
    Et en factorisant, on obtient la condition apparaissant
    dans le programme. Lorsque l'on remplace un espace par
    un saut de ligne, ne pas oublier de mettre à jour <tt>I10</tt>.
    La valeur de <tt>I32</tt> n'est plus tout-à-fait correcte,
    mais ce n'est pas très grave.
- en: |
    And if you factorise these conditions, you obtain the condition
    coded below. When we replace a space with a newline, we must
    update <tt>I10</tt>. The value of <tt>I32</tt> is no longer 
    significant, but this is not a problem.

- code: |
    « 0 0 10 CHR \-> CH LG I10 I32 NL
      «
       1 CH SIZE  FOR 
         I CH I I SUB
         CASE
           DUP " " ==
             THEN I 'I32' STO DROP
             END
           NL ==
            THEN I 'I10' STO
            END
         END
         IF I I10 - LG >
            I32 I10 > 
            I I32 ==  OR AND 
         THEN
           CH I32 NL REPL 'CH' STO
           I32 'I10' STO
         END
       NEXT
       CH
      »
    »
- section: SUBSG
  fr: Substitution globale
  en: Global Substitution
  subsg: 1
- fr: |
    Cette fonction permet d'effectuer une substitution globale
    sur une chaîne pour remplacer une séquence avec un backslash
    <tt>"\\->"</tt> par exemple, par le caractère correspondant
    <tt>\-></tt>. En entrée, la chaîne traitée au niveau 3, la séquence
    sans le backslash au niveau 2 (<tt>"->"</tt> dans l'exemple ci-dessus)
    et le code ASCII au niveau 1 (141 dans l'exemple).
- en: |
    This function performs a global substitution on a string, to replace
    a backslash-string, <tt>"\\->"</tt> for example, by the corresponding character
    <tt>\-></tt>. In input, the processed string at level 3, the replaced sequence
    without backslash at level 2 (<tt>"->"</tt> for the example above)
    and the ASCII code at level 1 (141 for the same example).
- code: |
    « 92 CHR ROT + SWAP CHR
      \-> ch av ap
      « WHILE ch av POS
        REPEAT
          ch 1 OVER av POS 1 - SUB
          ap +
          ch DUP av POS av SIZE +
          OVER SIZE SUB +
          'ch' STO
        END ch
      »
    »
- section: CVTCAR
  fr: Conversion de caractères
  en: Character Conversion
  cvtcar: 1
- fr: |
    Cette fonction remplace la conversion automatique effectuée par
    Conn4x, en remplaçant les séquences avec un backslash par les caractères
    correspondants. De plus, elle enlève la première ligne <tt>%HPHP</tt>
    qui a l'air de déranger la calculatrice.
- en: |
    This function replaces the automatic conversion which occurs
    when using Conn4x. It substitutes backslash-sequences with the corresponding
    special character. In addition, it removes the first line <tt>%HPHP</tt>
    which seems to bother the computer.
- code: |
    « 
      "<-" 142 @SUBSG@
      "->" 141 @SUBSG@
      "<=" 137 @SUBSG@
      ">=" 138 @SUBSG@
      "=/" 139 @SUBSG@
      IF DUP "%%HP" POS
      THEN
        DUP 10 CHR POS 1 +
        OVER SIZE
        SUB
      END
    »

- section: 0
  fr: Licence
  en: License
- fr: |
    Ce code est diffusé sous les mêmes termes que Perl, la licence GPL
    et la licence artistique.
- en: |
    This code is published under the same terms as Perl: GPL and Artistic License.
